# 最大子序和

## 问题

给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**示例:**

```python
输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

**进阶:**

如果你已经实现复杂度为 *O(n)* 的解法，尝试使用更为精妙的分治法求解。

## 实现

### 方法一

#### 执行时间：60ms

**思路：**

具有**最优子结构**和**重叠子问题**，动态规划的算法思路

**最大连续子序列和**只可能是以 *`0`~`n-1`* 中某个位置结尾。当遍历到第 *i* 个元素时，判断在他前面的连续子序列和是否大于 *0*，

- 如果大于 *0*，则以位置 *i* 结尾的最大连续子序列和为元素 *i* 和前面的连续子序列和相加；
- 如果小于等于 *0*，则以位置 *i* 结尾的最大连续子序列和为元素 *i* 。

**状态转移方程： sum[i]=max(sum[i-1]+a[i], a[i])**

```python
class Solution:
    def maxSubArray(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        max_sum = nums[0]						# 定义以位置 i 结尾的最大连续子序列和，初始化为列表首位
        max_here = nums[0]						# 定义以位置 i-1 结尾的最大连续子序列和，初始化为列表首位

        for i in range(1, len(nums)):			# 从列表第二位开始迭代
            if max_here <= 0:					# 判断以位置 i-1 结尾的最大连续子序列和是否小于等于 0
                max_here = nums[i]				# 小于等于 0，则忽略本次位置，下一位赋值给 max_here，继续迭代
            else:						
                max_here += nums[i]				# 大于 0，则以位置 i-1 结尾的最大连续子序列和 + 第 i 位 = 以位置 i 为结尾的最大连续子序列和

            max_sum = max(max_sum, max_here)	# 因为不确定 nums[i] 是否大于 0，所以需要比较 max_sum 和 max_here 的大小 

        return max_sum
```

